name: Deploy Second Brain v2.8.x

on:
  workflow_run:
    workflows: ["Second Brain v2.8.x CI/CD Pipeline"]
    types:
      - completed
    branches: [main]
  workflow_dispatch:
    inputs:
      environment:
        description: 'Deployment environment'
        required: true
        type: choice
        options:
          - staging
          - production
        default: staging
      version:
        description: 'Version to deploy (leave empty for latest)'
        required: false
        type: string

env:
  REGISTRY: ghcr.io
  IMAGE_NAME: ${{ github.repository }}

jobs:
  deploy:
    name: Deploy to ${{ inputs.environment || 'staging' }}
    runs-on: ubuntu-latest
    if: |
      github.event_name == 'workflow_dispatch' || 
      (github.event.workflow_run.conclusion == 'success' && github.event.workflow_run.head_branch == 'main')
    
    environment:
      name: ${{ inputs.environment || 'staging' }}
      url: ${{ inputs.environment == 'production' && 'https://second-brain.app' || 'https://staging.second-brain.app' }}
    
    steps:
      - name: Checkout deployment scripts
        uses: actions/checkout@v4
        with:
          sparse-checkout: |
            scripts/
            docker-compose.yml
            .env.example

      - name: Set deployment version
        id: version
        run: |
          if [ -n "${{ inputs.version }}" ]; then
            VERSION="${{ inputs.version }}"
          else
            VERSION="latest"
          fi
          echo "version=$VERSION" >> $GITHUB_OUTPUT
          echo "ðŸ·ï¸ Deploying version: $VERSION"

      - name: Configure deployment
        run: |
          ENV_NAME="${{ inputs.environment || 'staging' }}"
          echo "ðŸ”§ Configuring deployment for $ENV_NAME..."
          
          # Create deployment directory
          mkdir -p deployments/$ENV_NAME
          
          # Generate environment-specific docker-compose
          cat > deployments/$ENV_NAME/docker-compose.yml << 'EOF'
          version: '3.8'
          
          services:
            postgres:
              image: ankane/pgvector:v0.5.1
              restart: always
              environment:
                POSTGRES_USER: ${POSTGRES_USER}
                POSTGRES_PASSWORD: ${POSTGRES_PASSWORD}
                POSTGRES_DB: ${POSTGRES_DB}
              volumes:
                - postgres_data:/var/lib/postgresql/data
              healthcheck:
                test: ["CMD-SHELL", "pg_isready -U ${POSTGRES_USER} -d ${POSTGRES_DB}"]
                interval: 30s
                timeout: 10s
                retries: 5
              networks:
                - backend
            
            redis:
              image: redis:7-alpine
              restart: always
              command: redis-server --requirepass ${REDIS_PASSWORD}
              volumes:
                - redis_data:/data
              healthcheck:
                test: ["CMD", "redis-cli", "--raw", "ping"]
                interval: 30s
                timeout: 10s
                retries: 5
              networks:
                - backend
            
            api:
              image: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${{ steps.version.outputs.version }}
              restart: always
              ports:
                - "${API_PORT:-8000}:8000"
              environment:
                DATABASE_URL: postgresql://${POSTGRES_USER}:${POSTGRES_PASSWORD}@postgres:5432/${POSTGRES_DB}
                REDIS_URL: redis://:${REDIS_PASSWORD}@redis:6379
                OPENAI_API_KEY: ${OPENAI_API_KEY}
                API_TOKENS: ${API_TOKENS}
                ENVIRONMENT: ${ENV_NAME}
                LOG_LEVEL: ${LOG_LEVEL:-INFO}
              depends_on:
                postgres:
                  condition: service_healthy
                redis:
                  condition: service_healthy
              healthcheck:
                test: ["CMD", "curl", "-f", "http://localhost:8000/health"]
                interval: 30s
                timeout: 10s
                retries: 5
              networks:
                - backend
                - frontend
            
            nginx:
              image: nginx:alpine
              restart: always
              ports:
                - "${HTTP_PORT:-80}:80"
                - "${HTTPS_PORT:-443}:443"
              volumes:
                - ./nginx.conf:/etc/nginx/nginx.conf:ro
                - ./ssl:/etc/nginx/ssl:ro
              depends_on:
                api:
                  condition: service_healthy
              networks:
                - frontend
          
          volumes:
            postgres_data:
            redis_data:
          
          networks:
            backend:
              driver: bridge
            frontend:
              driver: bridge
          EOF
          
          # Create nginx configuration
          cat > deployments/$ENV_NAME/nginx.conf << 'EOF'
          events {
              worker_connections 1024;
          }
          
          http {
              upstream api {
                  server api:8000;
              }
              
              server {
                  listen 80;
                  server_name _;
                  
                  location / {
                      proxy_pass http://api;
                      proxy_set_header Host $host;
                      proxy_set_header X-Real-IP $remote_addr;
                      proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
                      proxy_set_header X-Forwarded-Proto $scheme;
                  }
                  
                  location /health {
                      access_log off;
                      proxy_pass http://api/health;
                  }
              }
          }
          EOF

      - name: Deploy application
        run: |
          echo "ðŸš€ Deploying Second Brain to ${{ inputs.environment || 'staging' }}..."
          echo "ðŸ“¦ Image: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${{ steps.version.outputs.version }}"
          
          # In a real deployment, you would:
          # 1. Copy files to target server
          # 2. Load environment variables
          # 3. Run docker-compose up -d
          # 4. Run database migrations
          # 5. Perform health checks
          
          echo "âœ… Deployment configuration prepared"
          echo "â„¹ï¸  Manual deployment steps required for actual deployment"

      - name: Post-deployment validation
        run: |
          echo "ðŸ” Post-deployment validation..."
          
          # These would be actual validation steps in production:
          echo "- [ ] API health check"
          echo "- [ ] Database connectivity"
          echo "- [ ] Redis connectivity"
          echo "- [ ] OpenAI API connectivity"
          echo "- [ ] Authentication endpoints"
          echo "- [ ] Critical API endpoints"
          
          echo "âœ… Deployment validation checklist generated"

      - name: Generate deployment summary
        run: |
          cat >> $GITHUB_STEP_SUMMARY << EOF
          # ðŸš€ Deployment Summary
          
          **Environment:** ${{ inputs.environment || 'staging' }}
          **Version:** ${{ steps.version.outputs.version }}
          **Triggered by:** ${{ github.actor }}
          **Time:** $(date -u +%Y-%m-%dT%H:%M:%SZ)
          
          ## Deployment Checklist
          - [x] Deployment configuration generated
          - [ ] Application deployed
          - [ ] Database migrations run
          - [ ] Health checks passed
          - [ ] Smoke tests passed
          
          ## Next Steps
          1. SSH to target server
          2. Navigate to deployment directory
          3. Run: \`docker-compose up -d\`
          4. Monitor logs: \`docker-compose logs -f\`
          5. Run smoke tests
          EOF

  rollback:
    name: Rollback Preparation
    runs-on: ubuntu-latest
    needs: deploy
    if: failure()
    
    steps:
      - name: Prepare rollback
        run: |
          echo "âš ï¸ Deployment failed - preparing rollback instructions..."
          
          cat >> $GITHUB_STEP_SUMMARY << EOF
          # âš ï¸ Rollback Instructions
          
          If deployment failed, follow these steps:
          
          1. **Immediate Rollback:**
             \`\`\`bash
             docker-compose down
             docker-compose up -d --scale api=0
             docker tag ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:previous ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:latest
             docker-compose up -d
             \`\`\`
          
          2. **Database Rollback (if needed):**
             \`\`\`bash
             docker-compose exec postgres psql -U \$POSTGRES_USER -d \$POSTGRES_DB < /backups/latest.sql
             \`\`\`
          
          3. **Monitor:**
             - Check application logs
             - Verify API endpoints
             - Monitor error rates
          
          4. **Notify:**
             - Update status page
             - Notify team in Slack
             - Create incident report
          EOF